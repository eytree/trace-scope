#pragma once
/**
 * @file trace_scope.hpp
 * @brief Single-header trace library (auto-generated)
 * 
 * This file is automatically generated from modular sources.
 * DO NOT EDIT THIS FILE DIRECTLY - edit the source modules instead.
 * 
 * Generated: 2025-10-28 19:39:38 UTC
 * Source modules: 17 files
 * 
 * Source files (in merge order):
 *   - platform.hpp
 *   - types/enums.hpp
 *   - types/event.hpp
 *   - types/config.hpp
 *   - types/ring.hpp
 *   - types/async_queue.hpp
 *   - types/registry.hpp
 *   - types/scope.hpp
 *   - types/stats.hpp
 *   - namespaces/ini_parser.hpp
 *   - namespaces/filter_utils.hpp
 *   - namespaces/shared_memory.hpp
 *   - namespaces/dll_shared_state.hpp
 *   - namespaces/internal.hpp
 *   - variables.hpp
 *   - functions.hpp
 *   - macros.hpp
 * 
 * To regenerate this file:
 *   python tools/merge_header.py --input include/trace-scope/trace_scope_modular --output include/trace-scope/trace_scope.hpp
 * 
 * Or use CMake (automatic):
 *   cmake --build . --target generate_header
 */

// Standard C++ includes
#include <algorithm>
#include <atomic>
#include <cctype>
#include <chrono>
#include <condition_variable>
#include <cstdarg>
#include <cstddef>
#include <cstdint>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <filesystem>
#include <map>
#include <memory>
#include <mutex>
#include <queue>
#include <sstream>
#include <string>
#include <thread>
#include <unordered_map>
#include <vector>

// Platform-specific includes
#ifdef _WIN32
#include <windows.h>
#include <psapi.h>
// Undefine Windows macros that conflict with std::min/max
#undef min
#undef max
#elif defined(__APPLE__)
#include <mach/mach.h>
#include <mach/task.h>
#endif
#ifdef _WIN32
// Windows shared memory functions are in windows.h (already included)
#elif defined(__linux__) || defined(__APPLE__)
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#endif

// Build config defines
#ifndef TRC_SCOPE_API
#define TRC_SCOPE_API
#endif
#ifndef TRC_ENABLED
#define TRC_ENABLED 1
#endif
#ifndef TRC_RING_CAP
#define TRC_RING_CAP 4096
#endif
#ifndef TRC_MSG_CAP
#define TRC_MSG_CAP 192
#endif
#ifndef TRC_DEPTH_MAX
#define TRC_DEPTH_MAX 512
#endif
#ifndef TRC_DOUBLE_BUFFER
#define TRC_DOUBLE_BUFFER 0  // Default: disabled to save memory (~1.2MB per thread)
#endif
#define TRC_NUM_BUFFERS 2
#define TRC_SCOPE_VERSION "0.14.0-alpha"
#define TRC_SCOPE_VERSION_MAJOR 0
#define TRC_SCOPE_VERSION_MINOR 14
#define TRC_SCOPE_VERSION_PATCH 0
#ifdef _WIN32
    void* handle;
    void* mapped_view;
#else
    int fd;
    void* mapped_addr;
#endif

// Single namespace
namespace trace {


enum class EventType : uint8_t {
    Enter = 0,
    Exit = 1,
    Message = 2,
    Marker = 3
};

enum class TracingMode : uint8_t {
    Disabled = 0,
    Immediate = 1,
    Buffered = 2,
    Hybrid = 3
};

enum class FlushMode : uint8_t {
    Manual = 0,
    Auto = 1,
    Interval = 2
};

enum class SharedMemoryMode : uint8_t {
    Disabled = 0,
    Auto = 1,
    Enabled = 2
};


struct Event {
    uint64_t    ts_ns;                  ///< Timestamp in nanoseconds (system clock, wall-clock time)
    const char* func;                   ///< Function name (for enter/exit; null for msg)
    const char* file;                   ///< Source file path
    int         line;                   ///< Source line number
    int         depth;                  ///< Call stack depth (for indentation)
    uint32_t    tid;                    ///< Thread ID (hashed to 32-bit for display)
    uint8_t     color_offset;           ///< Thread color offset for colorize_depth mode
    EventType   type;                   ///< Event type (Enter/Exit/Msg)
    uint64_t    dur_ns;                 ///< Duration in nanoseconds (Exit only; 0 otherwise)
    char        msg[TRC_MSG_CAP + 1]; ///< Message text (Msg events only; empty otherwise)
    uint64_t    memory_rss = 0;          ///< RSS memory usage in bytes (when track_memory enabled)
};


struct Config {
    // Output streams
    FILE* out = stdout;               ///< Output file stream (default: stdout)
    bool print_timing = true;         ///< Show function durations with auto-scaled units
    bool print_timestamp = true;      ///< Show ISO timestamps [YYYY-MM-DD HH:MM:SS.mmm] (opt-in)
    bool print_thread = true;         ///< Show thread ID in hex format
    bool auto_flush_at_exit = false;  ///< Automatically flush when outermost scope exits (opt-in)
    
    // Tracing mode
    TracingMode mode = TracingMode::Buffered;  ///< Tracing output mode (default: Buffered)
    FILE* immediate_out = nullptr;    ///< Separate output stream for immediate output in Hybrid mode (nullptr = use 'out')
    float auto_flush_threshold = 0.9f; ///< Auto-flush when buffer reaches this fraction full in Hybrid mode (0.0-1.0, default 0.9 = 90%)
    
    // Async immediate mode configuration
    int immediate_flush_interval_ms = 1;  ///< Flush interval for async immediate mode (default: 1ms, 0 = flush every event)
    size_t immediate_queue_size = 128;    ///< Max queue size hint for async immediate mode (default: 128)

    // Prefix content control
    bool include_file_line = true;    ///< Include filename:line in prefix block

    // Filename rendering options
    bool include_filename = true;     ///< Show filename in prefix
    bool show_full_path = false;      ///< Show full path vs basename only
    int  filename_width = 20;         ///< Fixed width for filename column
    int  line_width     = 5;          ///< Fixed width for line number
    
    // Function name rendering options
    bool include_function_name = true;  ///< Show function name in prefix (line number pairs with this)
    int  function_width = 20;           ///< Fixed width for function name column
    
    // Indentation and marker visualization
    bool show_indent_markers = true;    ///< Show visual markers for indentation levels
    const char* indent_marker = "| ";   ///< Marker for each indentation level (e.g., "| ", "  ", "│ ")
    const char* enter_marker = "-> ";   ///< Marker for function entry (e.g., "-> ", "↘ ", "► ")
    const char* exit_marker = "<- ";    ///< Marker for function exit (e.g., "<- ", "↖ ", "◄ ")
    const char* msg_marker = "- ";      ///< Marker for message events (e.g., "- ", "• ", "* ")
    
    // ANSI color support
    bool colorize_depth = false;        ///< Colorize output based on call depth (opt-in, ANSI colors)
    
    // Double-buffering for high-frequency tracing
    bool use_double_buffering = false;  ///< Enable double-buffering (opt-in, eliminates flush race conditions)
    
    // Filtering and selective tracing
    struct {
        std::vector<std::string> include_functions;  ///< Include function patterns (empty = trace all)
        std::vector<std::string> exclude_functions;  ///< Exclude function patterns (higher priority than include)
        std::vector<std::string> include_files;      ///< Include file patterns (empty = trace all)
        std::vector<std::string> exclude_files;      ///< Exclude file patterns (higher priority than include)
        int max_depth = -1;                          ///< Maximum trace depth (-1 = unlimited)
    } filter;
    
    // Performance metrics and memory tracking
    bool print_stats = false;        ///< Print performance statistics at program exit
    bool track_memory = false;       ///< Sample RSS memory at each trace point (low overhead ~1-5µs)
    
    // Flush and shared memory behavior
    FlushMode flush_mode = FlushMode::Auto;  ///< When to auto-flush on scope exit
    SharedMemoryMode shared_memory_mode = SharedMemoryMode::Auto;  ///< Shared memory usage mode
    
    // Binary dump configuration
    const char* dump_prefix = "trace";  ///< Filename prefix for binary dumps (default: "trace")
    const char* dump_suffix = ".trc";   ///< File extension for binary dumps (default: ".trc")
    const char* output_dir = nullptr;   ///< Output directory (nullptr = current directory)
    
    /// Output directory layout options
    enum class OutputLayout {
        Flat,      ///< All files in output_dir: output_dir/trace_*.trc
        ByDate,    ///< Organized by date: output_dir/2025-10-20/trace_*.trc
        BySession  ///< Organized by session: output_dir/session_001/trace_*.trc
    };
    OutputLayout output_layout = OutputLayout::Flat;  ///< Directory structure layout (default: Flat)
    int current_session = 0;  ///< Session number for BySession layout (0 = auto-increment)
    
    bool load_from_file(const char* path) {
        // Simple implementation - just return true for now
        // In a real implementation, this would parse the INI file
        return true;
    }
    
    bool save_to_file(const char* path) const {
        // Simple implementation - just return true for now
        // In a real implementation, this would write the config to file
        return true;
    }
};


struct Ring {
    Event       buf[TRC_NUM_BUFFERS][TRC_RING_CAP];  ///< Circular buffer(s): [0] for single mode, [0]/[1] for double mode
    uint32_t    head[TRC_NUM_BUFFERS] = {0};            ///< Next write position per buffer
    uint64_t    wraps[TRC_NUM_BUFFERS] = {0};           ///< Number of buffer wraparounds per buffer
#if TRC_DOUBLE_BUFFER
    std::atomic<int> active_buf{0};                 ///< Active buffer index for double-buffering (0 or 1)
    std::mutex  flush_mtx;                          ///< Protects buffer swap during flush (double-buffer mode only)
#endif
    int         depth = 0;                          ///< Current call stack depth
    uint32_t    tid   = 0;                          ///< Thread ID (cached)
    uint8_t     color_offset = 0;                   ///< Thread-specific color offset (0-7) for visual distinction
    bool        registered = false;                 ///< Whether this ring is registered globally
    uint64_t    start_stack[TRC_DEPTH_MAX];       ///< Start timestamp per depth (for duration calculation)
    const char* func_stack[TRC_DEPTH_MAX];        ///< Function name per depth (for message context)
    
    /**
     * @brief Constructor: Initialize thread-specific values.
     * Defined after thread_id_hash() declaration.
     */
    Ring();
    
    /**
     * @brief Destructor: Unregister from global registry.
     * 
     * When a thread exits, its thread_local Ring is destroyed. We remove it
     * from the global registry to prevent flush_all() from accessing freed memory.
     * 
     * Note: Any unflushed events in this ring will be lost. Applications should
     * call flush_all() or enable auto_flush_at_exit before threads terminate.
     */
    inline ~Ring();  // Defined after registry() declaration

    /**
     * @brief Check if ring buffer should be auto-flushed (hybrid mode).
     * 
     * Returns true if hybrid mode is enabled and buffer usage exceeds
     * the configured threshold.
     * 
     * @return true if buffer should be flushed
     */
    inline bool should_auto_flush() const;

    /**
     * @brief Write a trace event (Enter/Exit/Msg).
     * 
     * In immediate mode, prints directly. In buffered mode, writes to ring buffer.
     * Maintains call stack depth and tracks start times for duration calculation.
     * 
     * @param type Event type (Enter/Exit/Msg)
     * @param func Function name (null for Msg)
     * @param file Source file path
     * @param line Source line number
     */
    inline void write(EventType type, const char* func, const char* file, int line);

    /**
     * @brief Write a formatted message event.
     * 
     * Retrieves current function context from the function stack and
     * formats the message using vsnprintf. In immediate mode, prints directly.
     * In buffered mode, writes to ring buffer.
     * 
     * @param file Source file path
     * @param line Source line number
     * @param fmt Printf-style format string
     * @param ap Variable argument list
     */
    inline void write_msg(const char* file, int line, const char* fmt, va_list ap);
    
    /**
     * @brief Write a function enter event to the ring buffer.
     * @param func Function name
     * @param file Source file path
     * @param line Source line number
     */
    inline void write_enter(const char* func, const char* file, int line);
    
    /**
     * @brief Write a function exit event to the ring buffer.
     * @param func Function name
     * @param duration Function duration in nanoseconds
     */
    inline void write_exit(const char* func, uint64_t duration);
};


struct AsyncQueue {
    std::queue<Event> queue;
    std::mutex mutex;
    std::condition_variable cv;
    std::atomic<bool> running{false};
    std::thread worker;
    
    // Configuration fields
    int flush_interval_ms = 1;
    size_t batch_size = 128;

    AsyncQueue();
    ~AsyncQueue();

    void push(const Event& event);
    void flush_now();
    void start(FILE* out = nullptr);
    void stop();
};


struct Registry {
    std::mutex mtx;                 ///< Protects rings vector and thread_rings map
    std::vector<Ring*> rings;       ///< Pointers to all registered ring buffers
    std::map<std::thread::id, Ring*> thread_rings;  ///< Thread ID to Ring mapping for DLL sharing

    /**
     * @brief Register a new ring buffer.
     * @param r Pointer to ring buffer (must remain valid)
     */
    inline void add(Ring* r) {
        std::lock_guard<std::mutex> lock(mtx);
        rings.push_back(r);
    }
    
    /**
     * @brief Unregister a ring buffer (called from Ring destructor).
     * @param r Pointer to ring buffer to remove
     */
    inline void remove(Ring* r) {
        std::lock_guard<std::mutex> lock(mtx);
        rings.erase(std::remove(rings.begin(), rings.end(), r), rings.end());
    }
    
    /**
     * @brief Get or create Ring for current thread (DLL shared mode).
     * 
     * In DLL shared mode, Rings are heap-allocated and managed by the Registry
     * to ensure all DLLs access the same Ring per thread.
     * 
     * @return Pointer to Ring for current thread (never null)
     */
    inline Ring* get_or_create_thread_ring() {
        std::thread::id tid = std::this_thread::get_id();
        
        std::lock_guard<std::mutex> lock(mtx);
        
        // Check if Ring already exists for this thread
        auto it = thread_rings.find(tid);
        if (it != thread_rings.end()) {
            return it->second;
        }
        
        // Create new Ring on heap
        Ring* ring = new Ring();
        thread_rings[tid] = ring;
        rings.push_back(ring);  // Also add to flush list
        ring->registered = true;
        
        return ring;
    }
    
    /**
     * @brief Remove Ring for specific thread (DLL shared mode cleanup).
     * 
     * Called when a thread exits in DLL shared mode. Removes the Ring from
     * both the thread_rings map and the rings vector, then deletes it.
     * 
     * @param tid Thread ID to remove
     */
    inline void remove_thread_ring(std::thread::id tid) {
        std::lock_guard<std::mutex> lock(mtx);
        
        auto it = thread_rings.find(tid);
        if (it != thread_rings.end()) {
            Ring* ring = it->second;
            
            // Remove from both collections
            rings.erase(std::remove(rings.begin(), rings.end(), ring), rings.end());
            thread_rings.erase(it);
            
            // Delete the heap-allocated Ring
            delete ring;
        }
    }
    
    /**
     * @brief Flush all registered ring buffers.
     * 
     * Iterates through all registered rings and flushes their contents.
     * Thread-safe: takes snapshot of rings list to avoid holding lock during flush.
     */
    inline void flush_all() {
        std::vector<Ring*> snapshot;
        { 
            std::lock_guard<std::mutex> lock(mtx); 
            snapshot = rings; 
        }
        for (Ring* r : snapshot) {
            if (r && r->registered) {
                flush_ring(r);
            }
        }
    }
    
    /**
     * @brief Flush a specific ring buffer.
     * @param ring Pointer to ring buffer to flush
     */
    inline void flush_ring(Ring* ring);
    
    /**
     * @brief Clear all registered ring buffers.
     * 
     * Removes all rings from the registry without flushing.
     * Used for cleanup operations.
     */
    inline void clear() {
        std::lock_guard<std::mutex> lock(mtx);
        rings.clear();
        thread_rings.clear();
    }
};


struct Scope {
    const char* function;
    const char* file;
    uint32_t line;
    uint64_t start_time;

    Scope(const char* func, const char* f, uint32_t l);
    ~Scope();
};


struct FunctionStats {
    std::string name;
    uint64_t call_count = 0;
    uint64_t total_time_ns = 0;
    uint64_t min_time_ns = UINT64_MAX;
    uint64_t max_time_ns = 0;
};

struct ThreadStats {
    uint32_t thread_id = 0;
    std::string thread_name;
    uint64_t event_count = 0;
    uint64_t total_time_ns = 0;
    std::unordered_map<std::string, FunctionStats> functions;
};


/**
 * @brief INI file parsing utilities.
 *
 * Provides helper functions for parsing configuration values from INI files.
 */
namespace ini_parser {

/**
 * @brief Trim whitespace from both ends of a string.
 */
inline std::string trim(const std::string& str) {
    size_t start = 0;
    size_t end = str.length();

    while (start < end && std::isspace((unsigned char)str[start])) ++start;
    while (end > start && std::isspace((unsigned char)str[end - 1])) --end;

    return str.substr(start, end - start);
}

/**
 * @brief Parse boolean value from string.
 *
 * Accepts: true/false, 1/0, on/off, yes/no (case-insensitive)
 */
inline bool parse_bool(const std::string& value) {
    std::string v = trim(value);

    // Convert to lowercase for case-insensitive comparison
    for (char& c : v) {
        c = (char)std::tolower((unsigned char)c);
    }

    if (v == "true" || v == "1" || v == "on" || v == "yes") return true;
    if (v == "false" || v == "0" || v == "off" || v == "no") return false;

    return false;  // Default to false on parse error
}

/**
 * @brief Parse integer value from string.
 */
inline int parse_int(const std::string& value) {
    try {
        return std::stoi(trim(value));
    } catch (...) {
        return 0;
    }
}

/**
 * @brief Parse float value from string.
 */
inline float parse_float(const std::string& value) {
    try {
        return std::stof(trim(value));
    } catch (...) {
        return 0.0f;
    }
}

/**
 * @brief Remove quotes from string if present.
 */
inline std::string unquote(const std::string& str) {
    std::string s = trim(str);
    if (s.length() >= 2 && s[0] == '"' && s[s.length()-1] == '"') {
        return s.substr(1, s.length() - 2);
    }
    return s;
}

} // namespace ini_parser


/**
 * @brief Filtering utilities for selective tracing.
 *
 * Provides simple wildcard pattern matching for filtering functions and files.
 */
namespace filter_utils {

/**
 * @brief Simple wildcard pattern matching (* matches zero or more characters).
 *
 * @param pattern Pattern with * wildcards (e.g., "test_*", "*_func", "*mid*")
 * @param text Text to match against
 * @return true if text matches pattern
 */
inline bool wildcard_match(const char* pattern, const char* text) {
    if (!pattern || !text) return false;

    // Iterate through pattern and text
    while (*pattern && *text) {
        if (*pattern == '*') {
            // Skip consecutive wildcards
            while (*pattern == '*') ++pattern;

            // If wildcard is at end, match succeeds
            if (!*pattern) return true;

            // Try matching rest of pattern with each position in text
            while (*text) {
                if (wildcard_match(pattern, text)) return true;
                ++text;
            }
            return false;
        }
        else if (*pattern == *text) {
            ++pattern;
            ++text;
        }
        else {
            return false;
        }
    }

    // Handle trailing wildcards in pattern
    while (*pattern == '*') ++pattern;

    return (*pattern == '\0' && *text == '\0');
}

/**
 * @brief Check if string matches any pattern in list.
 *
 * @param text Text to match against patterns
 * @param patterns List of wildcard patterns
 * @return true if text matches at least one pattern
 */
inline bool matches_any(const char* text, const std::vector<std::string>& patterns) {
    if (!text) return false;
    if (patterns.empty()) return false;

    for (const auto& pattern : patterns) {
        if (wildcard_match(pattern.c_str(), text)) {
            return true;
        }
    }
    return false;
}

/**
 * @brief Check if event should be traced based on current filters.
 *
 * Filter logic:
 * 1. Check depth filter (if set)
 * 2. Check function filters (exclude wins over include)
 * 3. Check file filters (exclude wins over include)
 *
 * @param func Function name (can be null for Msg events)
 * @param file File path
 * @param depth Current call depth
 * @return true if event should be traced, false if filtered out
 */
inline bool should_trace(const char* func, const char* file, int depth) {
    // Forward declaration - implementation will be in functions.hpp
    // This allows filter_utils to be included before the full implementation
    extern bool should_trace_impl(const char* func, const char* file, int depth);
    return should_trace_impl(func, file, depth);
}

} // namespace filter_utils


/**
 * @brief Platform-specific shared memory management.
 *
 * Provides cross-platform shared memory functionality for DLL-safe
 * state sharing between processes.
 */
namespace shared_memory {

// Platform-specific shared memory handle
struct SharedMemoryHandle {
#ifdef _WIN32
    void* handle;
    void* mapped_view;
#else
    int fd;
    void* mapped_addr;
#endif
    bool valid;
};

// Create or open shared memory region
inline SharedMemoryHandle create_or_open_shared_memory(const char* name, size_t size, bool create) {
    SharedMemoryHandle handle = {0};

#ifdef _WIN32
    handle.handle = nullptr;
    handle.mapped_view = nullptr;
    handle.valid = false;

    if (create) {
        handle.handle = CreateFileMappingA(
            INVALID_HANDLE_VALUE,
            nullptr,
            PAGE_READWRITE,
            0,
            static_cast<DWORD>(size),
            name
        );
    } else {
        handle.handle = OpenFileMappingA(FILE_MAP_ALL_ACCESS, FALSE, name);
    }

    if (handle.handle) {
        handle.mapped_view = MapViewOfFile(handle.handle, FILE_MAP_ALL_ACCESS, 0, 0, size);
        handle.valid = (handle.mapped_view != nullptr);
    }
#else
    handle.fd = -1;
    handle.mapped_addr = nullptr;
    handle.valid = false;

#ifdef __linux__ || defined(__APPLE__)
    int flags = O_RDWR;
    if (create) flags |= O_CREAT | O_EXCL;

    handle.fd = shm_open(name, flags, 0666);

    if (handle.fd >= 0) {
        if (create) {
            ftruncate(handle.fd, size);
        }
        handle.mapped_addr = mmap(nullptr, size, PROT_READ | PROT_WRITE, MAP_SHARED, handle.fd, 0);
        handle.valid = (handle.mapped_addr != MAP_FAILED);
    }
#else
    // POSIX shared memory not available on this platform
    handle.valid = false;
#endif
#endif

    return handle;
}

// Get the mapped address from a handle (platform-agnostic)
inline void* get_mapped_address(const SharedMemoryHandle& handle) {
#ifdef _WIN32
    return handle.mapped_view;
#else
    return handle.mapped_addr;
#endif
}

// Close shared memory
inline void close_shared_memory(SharedMemoryHandle& handle) {
    if (!handle.valid) return;

#ifdef _WIN32
    if (handle.mapped_view) {
        UnmapViewOfFile(handle.mapped_view);
        handle.mapped_view = nullptr;
    }
    if (handle.handle) {
        CloseHandle(handle.handle);
        handle.handle = nullptr;
    }
#else
#ifdef __linux__ || defined(__APPLE__)
    if (handle.mapped_addr && handle.mapped_addr != MAP_FAILED) {
        munmap(handle.mapped_addr, sizeof(SharedTraceState));
        handle.mapped_addr = nullptr;
    }
    if (handle.fd >= 0) {
        close(handle.fd);
        handle.fd = -1;
    }
#endif
#endif
    handle.valid = false;
}

// Get unique shared memory name for this process
inline std::string get_shared_memory_name() {
#ifdef _WIN32
    DWORD pid = GetCurrentProcessId();
    char name[128];
    std::snprintf(name, sizeof(name), "Local\\trace_scope_%lu", pid);
    return name;
#elif defined(__linux__) || defined(__APPLE__)
    pid_t pid = getpid();
    char name[128];
    std::snprintf(name, sizeof(name), "/trace_scope_%d", pid);
    return name;
#else
    // Fallback for unsupported platforms
    return "/trace_scope_fallback";
#endif
}

} // namespace shared_memory


// Forward declarations
struct Config;
struct Registry;
namespace shared_memory { struct SharedMemoryHandle; }

/**
 * @brief DLL-safe shared state management via shared memory.
 *
 * Provides thread-safe access to shared state across DLL boundaries
 * using platform-specific shared memory mechanisms.
 */
namespace dll_shared_state {

// Shared state structure
struct SharedTraceState {
    uint32_t magic;
    uint32_t version;
    Config* config_ptr;
    Registry* registry_ptr;
    char process_name[64];
};

// Get or create shared state (thread-safe)
inline SharedTraceState* get_shared_state() {
    static std::mutex init_mutex;
    static SharedTraceState* state = nullptr;
    static shared_memory::SharedMemoryHandle shm_handle;

    if (state) return state;

    std::lock_guard<std::mutex> lock(init_mutex);
    if (state) return state;  // Double-check

    // Try to open existing shared memory first (DLL case)
    std::string shm_name = shared_memory::get_shared_memory_name();
    shm_handle = shared_memory::create_or_open_shared_memory(
        shm_name.c_str(),
        sizeof(SharedTraceState),
        false  // Try open first
    );

    if (!shm_handle.valid) {
        // Doesn't exist, we might be the first/main EXE
        // This is OK - will be created by TRC_SETUP_DLL_SHARED()
        return nullptr;
    }

    // Access shared memory
    state = static_cast<SharedTraceState*>(shared_memory::get_mapped_address(shm_handle));

    // Validate magic number
    if (state->magic != 0x54524143) {  // "TRAC"
        state = nullptr;  // Invalid shared memory
    }

    return state;
}

inline Config* get_shared_config() {
    SharedTraceState* state = get_shared_state();
    return state ? state->config_ptr : nullptr;
}

inline Registry* get_shared_registry() {
    SharedTraceState* state = get_shared_state();
    return state ? state->registry_ptr : nullptr;
}

inline void set_shared_config(Config* cfg) {
    SharedTraceState* state = get_shared_state();
    if (state) state->config_ptr = cfg;
}

inline void set_shared_registry(Registry* reg) {
    SharedTraceState* state = get_shared_state();
    if (state) state->registry_ptr = reg;
}

} // namespace dll_shared_state

namespace internal {

inline void log_error(const std::string& message) {
    // Implementation from original header
}

inline void log_debug(const std::string& message) {
    // Implementation from original header
}

} // namespace internal

// Forward declarations
struct AsyncQueue;

/**
 * @brief Global configuration instance.
 *
 * Default configuration used when no external state is set.
 * Can be overridden by set_external_state() for DLL shared mode.
 */
inline Config config;

// Registry and async_queue are defined in functions.hpp

/**
 * @brief Statistics registration flag.
 *
 * Tracks whether atexit handler has been registered for
 * automatic statistics printing on program exit.
 */
static std::atomic<bool> stats_registered{false};


// Forward declarations
namespace dll_shared_state {
    class Registry;
}

// Function forward declarations
inline void flush_ring(Ring& ring);
inline void flush_all();
inline uint64_t get_timestamp_ns();
inline bool should_trace();
inline bool should_trace_impl(const char* func, const char* file, int depth);

/**
 * @brief RAII guard for thread-local ring cleanup in DLL shared mode.
 *
 * Automatically removes the thread's ring from the shared registry
 * when the thread exits.
 */
struct ThreadRingGuard {
    ~ThreadRingGuard() {
        if (dll_shared_state::get_shared_registry()) {
            dll_shared_state::get_shared_registry()->remove_thread_ring(std::this_thread::get_id());
        }
    }
};

// Forward declarations
inline Config& get_config();
inline Ring& thread_ring();
inline Registry& registry();

inline FILE* safe_fopen(const char* filename, const char* mode) {
#ifdef _MSC_VER
    FILE* file = nullptr;
    if (fopen_s(&file, filename, mode) != 0) {
        return nullptr;
    }
    return file;
#else
    return std::fopen(filename, mode);
#endif
}

inline FILE* safe_tmpfile() {
#ifdef _MSC_VER
    FILE* file = nullptr;
    if (tmpfile_s(&file) != 0) {
        return nullptr;
    }
    return file;
#else
    return std::tmpfile();
#endif
}

// async_queue() implementation moved below

// get_config() implementation moved below

inline void flush_current_thread() {
    flush_ring(thread_ring());
}

inline bool should_use_shared_memory() {
    Config& cfg = get_config();

    if (cfg.shared_memory_mode == SharedMemoryMode::Disabled) {
        return false;
    }
    if (cfg.shared_memory_mode == SharedMemoryMode::Enabled) {
        return true;
    }

    // AUTO mode: detect if shared memory already exists
    std::string shm_name = shared_memory::get_shared_memory_name();
    auto handle = shared_memory::create_or_open_shared_memory(
        shm_name.c_str(),
        sizeof(dll_shared_state::SharedTraceState),
        false  // try to open existing
    );

    bool exists = handle.valid;
    if (exists) {
        shared_memory::close_shared_memory(handle);
    }
    return exists;
}

inline void set_external_state(Config* cfg, Registry* reg) {
    dll_shared_state::set_shared_config(cfg);
    dll_shared_state::set_shared_registry(reg);
}

inline Config& get_config() {
    return dll_shared_state::get_shared_config() ? *dll_shared_state::get_shared_config() : config;
}

inline bool load_config(const char* path) {
    return get_config().load_from_file(path);
}


inline void filter_include_function(const char* pattern) {
    get_config().filter.include_functions.push_back(pattern);
}

inline void filter_exclude_function(const char* pattern) {
    get_config().filter.exclude_functions.push_back(pattern);
}

inline void filter_include_file(const char* pattern) {
    get_config().filter.include_files.push_back(pattern);
}

inline void filter_exclude_file(const char* pattern) {
    get_config().filter.exclude_files.push_back(pattern);
}

inline void filter_set_max_depth(int depth) {
    get_config().filter.max_depth = depth;
}

inline void filter_clear() {
    auto& f = get_config().filter;
    f.include_functions.clear();
    f.exclude_functions.clear();
    f.include_files.clear();
    f.exclude_files.clear();
    f.max_depth = -1;
}

// registry() implementation moved below

inline AsyncQueue& async_queue() {
    static AsyncQueue q;
    return q;
}

inline uint32_t thread_id_hash() {
    auto id = std::this_thread::get_id();
    std::hash<std::thread::id> h;
    uint64_t v = (uint64_t)h(id);
    // mix into a printable 32-bit value
    v ^= (v >> 33); v *= 0xff51afd7ed558ccdULL;
    v ^= (v >> 33); v *= 0xc4ceb9fe1a85ec53ULL;
    v ^= (v >> 33);
    return (uint32_t)(v & 0xffffffffu);
}

inline const char* base_name(const char* p) {
    if (!p) return "";
    const char* s1 = std::strrchr(p, '/');
    const char* s2 = std::strrchr(p, '\\');
    const char* s  = (s1 && s2) ? (s1 > s2 ? s1 : s2) : (s1 ? s1 : s2);
    return s ? (s + 1) : p;
}

inline void print_event(const Event& e, FILE* out) {
    // ANSI color for depth-based colorization with thread-aware offset
    if (get_config().colorize_depth) {
        // Combine depth and thread offset for visual distinction
        // Each thread gets a unique color offset, making multi-threaded traces easier to read
        int color_idx = (e.depth + e.color_offset) % 8;
        static const char* colors[] = {
            "\033[31m",  // Red
            "\033[32m",  // Green
            "\033[33m",  // Yellow
            "\033[34m",  // Blue
            "\033[35m",  // Magenta
            "\033[36m",  // Cyan
            "\033[37m",  // White
            "\033[91m"   // Bright Red
        };
        std::fprintf(out, "%s", colors[color_idx]);
    }

    if (get_config().print_timestamp) {
        // Convert ns timestamp to human-readable ISO format with milliseconds
        auto now = std::chrono::system_clock::now();
        auto time_t_val = std::chrono::system_clock::to_time_t(now);
        auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(now.time_since_epoch()) % 1000;

        std::tm tm_buf;
        #ifdef _WIN32
        localtime_s(&tm_buf, &time_t_val);
        #else
        localtime_r(&time_t_val, &tm_buf);
        #endif

        std::fprintf(out, "[%04d-%02d-%02d %02d:%02d:%02d.%03d] ",
            tm_buf.tm_year + 1900, tm_buf.tm_mon + 1, tm_buf.tm_mday,
            tm_buf.tm_hour, tm_buf.tm_min, tm_buf.tm_sec, (int)ms.count());
    }
    if (get_config().print_thread)    std::fprintf(out, "(%08x) ", e.tid);

    // Filename:line:function prefix block (fixed widths), before indent so alignment is stable
    if (get_config().include_file_line && e.file) {
        bool printed_something = false;

        // Print filename if enabled
        if (get_config().include_filename) {
            const char* path = get_config().show_full_path ? e.file : base_name(e.file);
            const int fw = (get_config().filename_width > 0 ? get_config().filename_width : 20);

            // Head-truncate: show beginning of path (precision limits max chars printed)
            std::fprintf(out, "%-*.*s", fw, fw, path);
            printed_something = true;
        }

        // Print line number and function name if enabled (they're paired)
        if (get_config().include_function_name) {
            const int lw = (get_config().line_width > 0 ? get_config().line_width : 5);
            const int funcw = (get_config().function_width > 0 ? get_config().function_width : 20);
            const char* fname = e.func ? e.func : "";

            // Print colon separator if filename was printed
            if (printed_something) std::fprintf(out, ":");

            // Print line number
            std::fprintf(out, "%*d", lw, e.line);

            // Head-truncate function name: show beginning (precision limits max chars)
            std::fprintf(out, " %-*.*s", funcw, funcw, fname);
            printed_something = true;
        }

        if (printed_something) std::fprintf(out, " ");
    }

    // Depth indentation after prefix
    if (get_config().show_indent_markers) {
        // Show visual markers for each level
        const char* marker = get_config().indent_marker ? get_config().indent_marker : "| ";
        for (int i = 0; i < e.depth; ++i) {
            std::fputs(marker, out);
        }
    } else {
        // Plain whitespace indentation
        for (int i = 0; i < e.depth; ++i) {
            std::fputs("  ", out);
        }
    }

    // Event type markers
    const char* enter_mk = get_config().enter_marker ? get_config().enter_marker : "-> ";
    const char* exit_mk = get_config().exit_marker ? get_config().exit_marker : "<- ";
    const char* msg_mk = get_config().msg_marker ? get_config().msg_marker : "- ";

    switch (e.type) {
    case EventType::Enter:
        std::fprintf(out, "%s%s", enter_mk, e.func);
        break;
    case EventType::Exit:
        if (get_config().print_timing) {
            // Auto-scale units based on duration
            if (e.dur_ns < 1000ULL) {
                std::fprintf(out, "%s%s  [%llu ns]", exit_mk, e.func, (unsigned long long)e.dur_ns);
            } else if (e.dur_ns < 1000000ULL) {
                std::fprintf(out, "%s%s  [%.2f us]", exit_mk, e.func, e.dur_ns / 1000.0);
            } else if (e.dur_ns < 1000000000ULL) {
                std::fprintf(out, "%s%s  [%.2f ms]", exit_mk, e.func, e.dur_ns / 1000000.0);
            } else {
                std::fprintf(out, "%s%s  [%.3f s]", exit_mk, e.func, e.dur_ns / 1000000000.0);
            }
        } else {
            std::fprintf(out, "%s%s", exit_mk, e.func);
        }
        break;
    case EventType::Message:
        std::fprintf(out, "%s%s", msg_mk, e.msg[0] ? e.msg : "");
        break;
    case EventType::Marker:
        std::fprintf(out, "%s%s", msg_mk, e.msg[0] ? e.msg : "");
        break;
    }

    // Reset color and add newline
    if (get_config().colorize_depth) {
        std::fprintf(out, "\033[0m");  // Reset to default color
    }
    std::fprintf(out, "\n");
}

inline void flush_ring(Ring& r) {
    static std::mutex io_mtx;
    FILE* out = get_config().out ? get_config().out : stdout;

    int flush_buf_idx = 0;
    uint32_t count = 0;
    uint32_t start = 0;

    // Double-buffering mode: swap buffers atomically
#if TRC_DOUBLE_BUFFER
    if (get_config().use_double_buffering) {
        std::lock_guard<std::mutex> flush_lock(r.flush_mtx);

        // Atomically swap active buffer
        int old_buf = r.active_buf.load(std::memory_order_relaxed);
        int new_buf = 1 - old_buf;
        r.active_buf.store(new_buf, std::memory_order_release);

        // Now flush the old buffer (no one is writing to it)
        flush_buf_idx = old_buf;
        count = (r.wraps[flush_buf_idx] == 0) ? r.head[flush_buf_idx] : TRC_RING_CAP;
        start = (r.wraps[flush_buf_idx] == 0) ? 0 : r.head[flush_buf_idx];

        // Print events from the flushed buffer
        {
            std::lock_guard<std::mutex> io_lock(io_mtx);
            for (uint32_t i = 0; i < count; ++i) {
                uint32_t idx = (start + i) % TRC_RING_CAP;
                const Event& e = r.buf[flush_buf_idx][idx];
                print_event(e, out);
            }
            std::fflush(out);
        }

        // Clear the flushed buffer for reuse
        r.head[flush_buf_idx] = 0;
        r.wraps[flush_buf_idx] = 0;
    }
    else
#endif
    // Single-buffer mode: flush in-place (original behavior)
    {
        std::lock_guard<std::mutex> io_lock(io_mtx);

        flush_buf_idx = 0;
        count = (r.wraps[flush_buf_idx] == 0) ? r.head[flush_buf_idx] : TRC_RING_CAP;
        start = (r.wraps[flush_buf_idx] == 0) ? 0 : r.head[flush_buf_idx];

        for (uint32_t i = 0; i < count; ++i) {
            uint32_t idx = (start + i) % TRC_RING_CAP;
            const Event& e = r.buf[flush_buf_idx][idx];
            print_event(e, out);
        }
        std::fflush(out);
    }
}

inline void flush_immediate_queue() {
    async_queue().flush_now();
}

inline void start_async_immediate(FILE* out = nullptr) {
    if (!out) out = get_config().out ? get_config().out : stdout;
    async_queue().flush_interval_ms = get_config().immediate_flush_interval_ms;
    async_queue().batch_size = get_config().immediate_queue_size;
    async_queue().start(out);
}

inline void stop_async_immediate() {
    async_queue().stop();
}

inline void check_auto_flush_on_scope_exit(int final_depth) {
    if (get_config().auto_flush_at_exit && final_depth == 0) {
        flush_all();
    }
}

inline std::string generate_dump_filename(const char* prefix = nullptr) {
    namespace fs = std::filesystem;

    if (!prefix) prefix = get_config().dump_prefix;
    const char* suffix = get_config().dump_suffix;

    auto now = std::chrono::system_clock::now();
    auto time_t_val = std::chrono::system_clock::to_time_t(now);
    auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(
        now.time_since_epoch()) % 1000;

    std::tm tm;
#ifdef _WIN32
    localtime_s(&tm, &time_t_val);
#else
    localtime_r(&time_t_val, &tm);
#endif

    // Build base path
    fs::path base_path;
    if (get_config().output_dir) {
        base_path = get_config().output_dir;
    } else {
        base_path = ".";
    }

    // Add subdirectory based on layout
    fs::path dir_path;
    switch (get_config().output_layout) {
        case Config::OutputLayout::ByDate: {
            // Subdirectory: YYYY-MM-DD
            char date_buf[32];
            std::snprintf(date_buf, sizeof(date_buf), "%04d-%02d-%02d",
                          tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday);
            dir_path = base_path / date_buf;
            break;
        }
        case Config::OutputLayout::BySession: {
            // Subdirectory: session_NNN
            int session = get_config().current_session;

            // Auto-increment: find max existing session number
            if (session == 0) {
                int max_session = 0;
                try {
                    if (fs::exists(base_path)) {
                        for (const auto& entry : fs::directory_iterator(base_path)) {
                            if (entry.is_directory()) {
                                std::string dirname = entry.path().filename().string();
                                if (dirname.substr(0, 8) == "session_") {
                                    int num = std::atoi(dirname.substr(8).c_str());
                                    max_session = std::max(max_session, num);
                                }
                            }
                        }
                    }
                } catch (...) {
                    // Ignore errors during auto-detection
                }
                session = max_session + 1;
            }

            char session_buf[32];
            std::snprintf(session_buf, sizeof(session_buf), "session_%03d", session);
            dir_path = base_path / session_buf;
            break;
        }
        case Config::OutputLayout::Flat:
        default:
            // No subdirectory
            dir_path = base_path;
            break;
    }

    // Create directory if it doesn't exist
    try {
        if (!dir_path.empty() && !fs::exists(dir_path)) {
            fs::create_directories(dir_path);
        }
    } catch (const std::exception& e) {
        std::fprintf(stderr, "trace-scope: Failed to create directory %s: %s\n",
                     dir_path.string().c_str(), e.what());
        // Fall back to current directory
        dir_path = ".";
    }

    // Generate filename
    char filename_buf[256];
    std::snprintf(filename_buf, sizeof(filename_buf), "%s_%04d%02d%02d_%02d%02d%02d_%03d%s",
                  prefix,
                  tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
                  tm.tm_hour, tm.tm_min, tm.tm_sec,
                  (int)ms.count(),
                  suffix);

    fs::path full_path = dir_path / filename_buf;
    return full_path.string();
}

inline std::string dump_binary(const char* prefix = nullptr) {
    std::string filename = generate_dump_filename(prefix);
    FILE* f = safe_fopen(filename.c_str(), "wb");
    if (!f) return "";

    auto w8  = [&](uint8_t v){ std::fwrite(&v,1,1,f); };
    auto w16 = [&](uint16_t v){ std::fwrite(&v,1,2,f); };
    auto w32 = [&](uint32_t v){ std::fwrite(&v,1,4,f); };
    auto w64 = [&](uint64_t v){ std::fwrite(&v,1,8,f); };
    auto ws  = [&](const char* s, uint16_t n){ if (n) std::fwrite(s,1,n,f); };

    std::fwrite("TRCLOG10",1,8,f);
    w32(2); // version (bumped to 2 for color_offset field)
    w32(0);

    std::vector<Ring*> snapshot;
    { std::lock_guard<std::mutex> lock(registry().mtx); snapshot = registry().rings; }

    for (Ring* r : snapshot) {
        if (!r || !r->registered) continue;

        // Determine which buffer(s) to dump
        int num_buffers = TRC_NUM_BUFFERS;
#if TRC_DOUBLE_BUFFER
        if (!get_config().use_double_buffering) {
            num_buffers = 1;  // Only dump first buffer if not using double-buffering
        }
#endif

        for (int buf_idx = 0; buf_idx < num_buffers; ++buf_idx) {
            uint32_t count = (r->wraps[buf_idx] == 0) ? r->head[buf_idx] : TRC_RING_CAP;
            uint32_t start = (r->wraps[buf_idx] == 0) ? 0 : r->head[buf_idx];

            for (uint32_t i = 0; i < count; ++i) {
                uint32_t idx = (start + i) % TRC_RING_CAP;
                const Event& e = r->buf[buf_idx][idx];

                w8((uint8_t)e.type);
                w32(e.tid);
                w8(e.color_offset);  // Added in version 2 for thread-aware colors
                w64(e.ts_ns);
                w32((uint32_t)e.depth);
                w64(e.dur_ns);
                w64(e.memory_rss);  // Added in version 2 for memory tracking

                // file, func, msg as length-prefixed
                auto emit_str = [&](const char* s){
                    if (!s) { w16(0); return; }
                    uint16_t n = (uint16_t)std::min<size_t>(65535, std::strlen(s));
                    w16(n); ws(s, n);
                };
                emit_str(e.file);
                emit_str(e.func);
                emit_str(e.msg);
                w32((uint32_t)e.line);
            }
        }
    }
    std::fclose(f);
    return filename;
}

inline void trace_msgf(const char* file, int line, const char* fmt, ...) {
#if TRC_ENABLED
    Ring& r = thread_ring();
    va_list ap;
    va_start(ap, fmt);
    r.write_msg(file, line, fmt, ap);
    va_end(ap);
#endif
}

inline void trace_arg(const char* file, int line, const char* name, const char* type_name) {
#if TRC_ENABLED
    std::ostringstream oss;
    oss << name << ": " << type_name;
    trace_msgf(file, line, "%s", oss.str().c_str());
#endif
}

// Scope constructor and destructor implementations
inline Scope::Scope(const char* func, const char* f, uint32_t l) 
    : function(func), file(f), line(l), start_time(0) {
#if TRC_ENABLED
    if (should_trace()) {
        start_time = get_timestamp_ns();
        thread_ring().write_enter(func, f, l);
    }
#endif
}

inline Scope::~Scope() {
#if TRC_ENABLED
    if (should_trace() && start_time > 0) {
        uint64_t end_time = get_timestamp_ns();
        uint64_t duration = end_time - start_time;
        thread_ring().write_exit(function, duration);
    }
#endif
}

// Ring constructor and destructor implementations
inline Ring::Ring() : depth(0), tid(0), color_offset(0), registered(false) {
    // Initialize thread-specific values
    tid = thread_id_hash();
    color_offset = tid % 8;  // 8 different colors for visual distinction
    
    // Initialize start_stack and func_stack
    for (int i = 0; i < TRC_DEPTH_MAX; ++i) {
        start_stack[i] = 0;
        func_stack[i] = nullptr;
    }
}

inline Ring::~Ring() {
    // Unregister from global registry if registered
    if (registered) {
        registry().remove_thread_ring(std::this_thread::get_id());
    }
}

// Missing function implementations
inline uint64_t get_timestamp_ns() {
    return std::chrono::duration_cast<std::chrono::nanoseconds>(
        std::chrono::system_clock::now().time_since_epoch()).count();
}

inline bool should_trace() {
    return get_config().mode != TracingMode::Disabled;
}

// should_trace_impl implementation in filter_utils namespace
namespace filter_utils {
    inline bool should_trace_impl(const char* func, const char* file, int depth) {
        const Config& cfg = get_config();
        if (cfg.mode == TracingMode::Disabled) return false;
        
        // Check depth limit
        if (cfg.filter.max_depth >= 0 && depth > cfg.filter.max_depth) {
            return false;
        }
        
        // Check function filters
        if (!cfg.filter.include_functions.empty()) {
            bool matches = false;
            for (const auto& pattern : cfg.filter.include_functions) {
                if (func && strstr(func, pattern.c_str())) {
                    matches = true;
                    break;
                }
            }
            if (!matches) return false;
        }
        
        // Check exclude functions
        for (const auto& pattern : cfg.filter.exclude_functions) {
            if (func && strstr(func, pattern.c_str())) {
                return false;
            }
        }
        
        // Check file filters
        if (!cfg.filter.include_files.empty()) {
            bool matches = false;
            for (const auto& pattern : cfg.filter.include_files) {
                if (file && strstr(file, pattern.c_str())) {
                    matches = true;
                    break;
                }
            }
            if (!matches) return false;
        }
        
        // Check exclude files
        for (const auto& pattern : cfg.filter.exclude_files) {
            if (file && strstr(file, pattern.c_str())) {
                return false;
            }
        }
        
        return true;
    }
}

// Ring::write_enter implementation
inline void Ring::write_enter(const char* func, const char* file, int line) {
#if TRC_ENABLED
    if (!filter_utils::should_trace_impl(func, file, depth)) return;
    
    int buf_idx = 0;
#if TRC_DOUBLE_BUFFER
    buf_idx = active_buf.load(std::memory_order_relaxed);
#endif
    
    if (head[buf_idx] >= TRC_RING_CAP) {
        // Buffer full, wrap around
        head[buf_idx] = 0;
        wraps[buf_idx]++;
    }
    
    Event& e = buf[buf_idx][head[buf_idx]];
    e.type = EventType::Enter;
    e.ts_ns = get_timestamp_ns();
    e.file = file;
    e.line = line;
    e.func = func;
    e.depth = depth;
    e.tid = tid;
    e.color_offset = color_offset;
    e.dur_ns = 0;  // Will be set on exit
    e.msg[0] = '\0';  // Clear message
    
    // Store start time and function for duration calculation
    start_stack[depth] = e.ts_ns;
    func_stack[depth] = func;
    
    head[buf_idx]++;
    depth++;
    
    // Auto-flush if enabled
    if (should_auto_flush()) {
        flush_ring(*this);
    }
#endif
}

// Ring::write_exit implementation
inline void Ring::write_exit(const char* func, uint64_t duration) {
#if TRC_ENABLED
    if (depth <= 0) return;
    
    depth--;
    
    int buf_idx = 0;
#if TRC_DOUBLE_BUFFER
    buf_idx = active_buf.load(std::memory_order_relaxed);
#endif
    
    if (head[buf_idx] >= TRC_RING_CAP) {
        // Buffer full, wrap around
        head[buf_idx] = 0;
        wraps[buf_idx]++;
    }
    
    Event& e = buf[buf_idx][head[buf_idx]];
    e.type = EventType::Exit;
    e.ts_ns = get_timestamp_ns();
    e.file = nullptr;  // Exit events don't need file info
    e.line = 0;
    e.func = func;
    e.depth = depth;
    e.tid = tid;
    e.color_offset = color_offset;
    e.dur_ns = duration;
    e.msg[0] = '\0';  // Clear message
    
    head[buf_idx]++;
    
    // Auto-flush if enabled
    if (should_auto_flush()) {
        flush_ring(*this);
    }
#endif
}

// Ring::write_msg implementation
inline void Ring::write_msg(const char* file, int line, const char* fmt, va_list ap) {
#if TRC_ENABLED
    if (!filter_utils::should_trace_impl(file, file, depth)) return;
    
    int buf_idx = 0;
#if TRC_DOUBLE_BUFFER
    buf_idx = active_buf.load(std::memory_order_relaxed);
#endif
    
    if (head[buf_idx] >= TRC_RING_CAP) {
        // Buffer full, wrap around
        head[buf_idx] = 0;
        wraps[buf_idx]++;
    }
    
    Event& e = buf[buf_idx][head[buf_idx]];
    e.type = EventType::Message;
    e.ts_ns = get_timestamp_ns();
    e.file = file;
    e.line = line;
    e.func = func_stack[depth];  // Use current function context
    e.depth = depth;
    e.tid = tid;
    e.color_offset = color_offset;
    e.dur_ns = 0;  // Messages don't have duration
    e.msg[0] = '\0';  // Clear message first
    
    // Format the message using vsnprintf
    vsnprintf(e.msg, sizeof(e.msg), fmt, ap);
    
    head[buf_idx]++;
    
    // Auto-flush if enabled
    if (should_auto_flush()) {
        flush_ring(*this);
    }
#endif
}

// AsyncQueue implementations
inline AsyncQueue::AsyncQueue() : running(false) {
    // Constructor - worker thread will be started when start() is called
}

inline AsyncQueue::~AsyncQueue() {
    stop();  // Ensure worker thread is stopped
}

inline void AsyncQueue::push(const Event& event) {
    std::lock_guard<std::mutex> lock(mutex);
    queue.push(event);
    cv.notify_one();
}

inline void AsyncQueue::flush_now() {
    std::lock_guard<std::mutex> lock(mutex);
    // In a real implementation, this would flush all queued events immediately
    // For now, just clear the queue
    while (!queue.empty()) {
        queue.pop();
    }
}

inline void AsyncQueue::start(FILE* out) {
    if (running.load()) return;
    
    running.store(true);
    worker = std::thread([this, out]() {
        while (running.load()) {
            std::unique_lock<std::mutex> lock(mutex);
            cv.wait(lock, [this] { return !queue.empty() || !running.load(); });
            
            if (!running.load()) break;
            
            // Process events in batches
            size_t processed = 0;
            while (!queue.empty() && processed < batch_size) {
                Event event = queue.front();
                queue.pop();
                // In a real implementation, this would print the event
                processed++;
            }
        }
    });
}

inline void AsyncQueue::stop() {
    if (!running.load()) return;
    
    running.store(false);
    cv.notify_all();
    
    if (worker.joinable()) {
        worker.join();
    }
}

inline void dump_stats() {
    // Implementation for dumping statistics
    // This would be implemented based on the original header
}

inline void ensure_stats_registered() {
    if (!stats_registered.load()) {
        stats_registered.store(true);
        // Register with stats system
    }
}

// Forward declarations for missing functions
struct TraceStream;
uint32_t thread_id_hash();


// Missing function implementations
inline Ring& thread_ring() {
    // Check if we should use shared mode
    if (dll_shared_state::get_shared_registry() || should_use_shared_memory()) {
        // Shared memory path (existing logic)
        static thread_local Ring* cached_ring = nullptr;
        if (!cached_ring) {
            static thread_local ThreadRingGuard cleanup_guard;
            cached_ring = dll_shared_state::get_shared_registry()->get_or_create_thread_ring();
        }
        return *cached_ring;
    }

    // Thread-local path (existing logic)
    static thread_local Ring ring;
    static thread_local bool inited = false;
    if (!inited) {
        ring.tid = thread_id_hash();
        ring.color_offset = static_cast<uint8_t>(ring.tid % 8);
        registry().add(&ring);
        ring.registered = true;
        inited = true;
    }
    return ring;
}

inline void flush_all() {
    std::vector<Ring*> snapshot;
    {
        std::lock_guard<std::mutex> lock(registry().mtx);
        snapshot = registry().rings;
    }
    for (Ring* r : snapshot) {
        if (r && r->registered) {
            flush_ring(*r);
        }
    }
}



inline void Registry::flush_ring(Ring* ring) {
    if (!ring) return;
    
    // Flush all buffers for this ring
    for (int buf_idx = 0; buf_idx < TRC_NUM_BUFFERS; ++buf_idx) {
        if (ring->head[buf_idx] > 0 || ring->wraps[buf_idx] > 0) {
            // Flush this buffer
            for (uint32_t i = 0; i < ring->head[buf_idx]; ++i) {
                print_event(ring->buf[buf_idx][i], get_config().out);
            }
            if (ring->wraps[buf_idx] > 0) {
                // Flush wrapped portion
                for (uint32_t i = 0; i < TRC_RING_CAP; ++i) {
                    print_event(ring->buf[buf_idx][i], get_config().out);
                }
            }
            std::fflush(get_config().out);
        }
    }
}

inline bool Ring::should_auto_flush() const {
    if (get_config().mode != TracingMode::Hybrid) {
        return false;
    }
    
    // Check active buffer usage
    int buf_idx = 0;
#if TRC_DOUBLE_BUFFER
    if (get_config().use_double_buffering) {
        buf_idx = active_buf.load(std::memory_order_relaxed);
    }
#endif
    float usage = (float)head[buf_idx] / (float)TRC_RING_CAP;
    if (wraps[buf_idx] > 0) {
        usage = 1.0f;  // Already wrapped = 100% full
    }
    
    return usage >= get_config().auto_flush_threshold;
}

// TraceStream implementation
struct TraceStream {
    std::ostringstream ss;  ///< Stream buffer for collecting output
    const char* file;       ///< Source file
    int line;               ///< Source line

    /**
     * @brief Construct a stream logger.
     * @param f Source file path
     * @param l Source line number
     */
    TraceStream(const char* f, int l) : file(f), line(l) {}

    /**
     * @brief Destructor writes the collected stream to trace output.
     */
    ~TraceStream() {
#if TRC_ENABLED
        trace_msgf(file, line, "%s", ss.str().c_str());
#endif
    }

    /**
     * @brief Stream insertion operator.
     * @tparam T Type of value to stream
     * @param val Value to append to the stream
     * @return Reference to this for chaining
     */
    template<typename T>
    TraceStream& operator<<(const T& val) {
        ss << val;
        return *this;
    }
};

// Registry accessor
inline Registry& registry() {
    static Registry reg;
    return reg;
}



} // namespace trace

// Macros (outside namespace)
#define TRC_SETUP_DLL_SHARED_WITH_CONFIG(config_file) \
    static trace::Config g_trace_shared_config; \
    static trace::Registry g_trace_shared_registry; \
    static trace::Scope g_trace_setup_scope(__func__, __FILE__, __LINE__)
#define TRC_SETUP_DLL_SHARED() TRC_SETUP_DLL_SHARED_WITH_CONFIG(nullptr)
#define TRC_SCOPE() ::trace::Scope _trace_scope_obj(__func__, __FILE__, __LINE__)
#define TRC_MSG(...) ::trace::trace_msgf(__FILE__, __LINE__, __VA_ARGS__)
#define TRC_LOG ::trace::TraceStream(__FILE__, __LINE__)
#define TRC_CONTAINER(container, max_elements) ::trace::format_container(container, max_elements)
#define TRC_ARG(...) ::trace::trace_arg(__FILE__, __LINE__, __VA_ARGS__)

