/**
 * @file trace_scope.hpp
 * @brief Single-header C++ tracing library with per-thread ring buffers
 * 
 * DO NOT EDIT THIS FILE DIRECTLY - edit the source modules instead.
 * 
 * Generated: 2025-10-27 22:56:16 UTC
 * Source modules: 16 files
 * 
 * This file is generated from modular source files using AST-based extraction
 * and merging. The modular architecture allows for better maintainability
 * while preserving the single-header library benefits.
 * 
 * For development, see:
 * - Source: include/trace-scope/trace_scope_modular/
 * - Extraction: tools/extract_modular.py
 * - Merging: tools/ast_aware_merger.py
 */

#pragma once

#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\apiset.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\apisetcconv.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\basetsd.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\bcrypt.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\cderr.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\driverspecs.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\guiddef.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\inaddr.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\kernelspecs.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\ktmtypes.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\minwindef.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\poppack.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\pshpack1.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\pshpack2.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\pshpack4.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\pshpack8.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\rpc.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\rpcasync.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\rpcdce.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\rpcdcep.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\rpcndr.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\rpcnterr.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\rpcsal.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\sdkddkver.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\sdv_driverspecs.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\specstrings.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\specstrings_strict.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\specstrings_undef.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\stralign.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\tvout.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\winapifamily.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\windef.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\winerror.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\winpackagefamily.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\winsmcrd.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\wnnc.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\wtypes.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\shared\wtypesbase.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_malloc.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_memcpy_s.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_memory.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_search.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_share.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_startup.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_stdio_config.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_terminate.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_wconio.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_wctype.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_wdirect.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_wio.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_wprocess.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_wstdio.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_wstdlib.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_wstring.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_wtime.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\crtdbg.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\ctype.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\errno.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\fcntl.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\float.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\locale.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\malloc.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\math.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\process.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\share.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\stddef.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\stdio.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\stdlib.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\string.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\sys/stat.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\sys/types.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\time.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\wchar.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\apiquery2.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\cguid.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\combaseapi.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\coml2api.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\commdlg.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\consoleapi.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\consoleapi2.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\consoleapi3.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\datetimeapi.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\dde.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\ddeml.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\debugapi.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\dlgs.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\dpapi.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\enclaveapi.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\errhandlingapi.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\fibersapi.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\fileapi.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\fileapifromapp.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\handleapi.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\heapapi.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\ime_cmodes.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\imm.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\interlockedapi.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\ioapiset.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\jobapi.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\jobapi2.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\joystickapi.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\libloaderapi.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\lzexpand.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\mciapi.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\mcx.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\memoryapi.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\minwinbase.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\mmeapi.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\mmiscapi.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\mmiscapi2.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\mmsyscom.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\mmsystem.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\msxml.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\namedpipeapi.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\namespaceapi.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\nb30.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\ncrypt.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\oaidl.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\objbase.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\objidl.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\objidlbase.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\ole2.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\oleauto.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\oleidl.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\playsoundapi.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\processenv.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\processthreadsapi.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\processtopologyapi.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\profileapi.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\propidl.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\propidlbase.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\prsht.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\psapi.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\realtimeapiset.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\reason.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\rpcnsi.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\rpcnsip.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\securityappcontainer.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\securitybaseapi.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\servprov.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\shellapi.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\stringapiset.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\synchapi.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\sysinfoapi.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\systemtopologyapi.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\threadpoolapiset.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\threadpoollegacyapiset.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\timeapi.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\timezoneapi.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\unknwn.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\unknwnbase.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\urlmon.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\utilapiset.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\verrsrc.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\winbase.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\wincon.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\wincontypes.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\wincrypt.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\windows.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\winefs.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\wingdi.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\winioctl.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\winnetwk.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\winnls.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\winnt.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\winperf.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\winreg.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\winscard.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\winsock.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\winspool.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\winsvc.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\winuser.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\winver.h>
#include <C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\um\wow64apiset.h>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_bit_utils.hpp>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_chrono.hpp>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_heap_algorithms.hpp>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_iter_core.hpp>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_minmax.hpp>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_ostream.hpp>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_sanitizer_annotate_container.hpp>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_string_view.hpp>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_system_error_abi.hpp>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_threads_core.hpp>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\__msvc_xlocinfo_types.hpp>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\algorithm>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ammintrin.h>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\atomic>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\cctype>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\cerrno>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\cfloat>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\chrono>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\climits>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\clocale>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\cmath>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\concurrencysal.h>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\crtdefs.h>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\cstdarg>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\cstddef>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\cstdint>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\cstdio>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\cstdlib>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\cstring>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ctime>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\cwchar>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\eh.h>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\emmintrin.h>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\exception>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\excpt.h>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\filesystem>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\immintrin.h>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\initializer_list>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\intrin.h>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\intrin0.inl.h>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iomanip>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ios>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iosfwd>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\istream>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\iterator>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\limits>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\limits.h>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\locale>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\map>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\memory>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\mmintrin.h>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\mutex>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\new>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\nmmintrin.h>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\pmmintrin.h>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\ratio>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\sal.h>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\setjmp.h>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\smmintrin.h>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\sstream>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\stdarg.h>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\stdexcept>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\stdint.h>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\streambuf>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\string>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\system_error>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\thread>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\tmmintrin.h>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\tuple>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\type_traits>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\typeinfo>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\use_ansi.h>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\utility>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vadefs.h>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime.h>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_exception.h>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_new.h>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_new_debug.h>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_startup.h>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_string.h>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vcruntime_typeinfo.h>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\vector>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\wmmintrin.h>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xatomic.h>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xcall_once.h>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xerrc.h>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xfacet>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xfilesystem_abi.h>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xiosbase>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xkeycheck.h>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocale>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocbuf>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocinfo>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocmes>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocmon>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xlocnum>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xloctime>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmemory>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xmmintrin.h>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xnode_handle.h>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xpolymorphic_allocator.h>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xstring>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xthreads.h>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtimec.h>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtr1common>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xtree>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\xutility>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\yvals.h>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\yvals_core.h>
#include <C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.44.35207\include\zmmintrin.h>


// Single namespace
namespace trace {


enum class EventType : uint8_t {
    Enter = 0,
    Exit = 1,
    Message = 2,
    Marker = 3
};

enum class TracingMode : uint8_t {
    Disabled = 0,
    Immediate = 1,
    Buffered = 2,
    Hybrid = 3
};

enum class FlushMode : uint8_t {
    Manual = 0,
    Auto = 1,
    Interval = 2
};

enum class SharedMemoryMode : uint8_t {
    Disabled = 0,
    Auto = 1,
    Enabled = 2
};


struct Event {
    uint64_t timestamp;           ///< Timestamp in nanoseconds
    EventType type;               ///< Event type
    uint32_t depth;              ///< Call stack depth
    const char* function;        ///< Function name
    const char* file;            ///< Source file
    uint32_t line;               ///< Source line
    char message[TRC_MSG_CAP];   ///< Message buffer
};


struct Config {
    TracingMode mode = TracingMode::Disabled;
    FlushMode flush_mode = FlushMode::Auto;
    SharedMemoryMode shared_memory_mode = SharedMemoryMode::Auto;
    uint32_t max_depth = TRC_DEPTH_MAX;
    bool auto_flush = true;
    uint32_t flush_interval_ms = 1000;
    
    struct {
        std::vector<std::string> include_functions;
        std::vector<std::string> exclude_functions;
        std::vector<std::string> include_files;
        std::vector<std::string> exclude_files;
        uint32_t max_depth = TRC_DEPTH_MAX;
    } filter;
    
    std::string config_file;
    FILE* output_file = nullptr;
    
    void load_from_file(const std::string& path);
    void save_to_file(const std::string& path) const;
};


struct Ring {
    Event buffers[TRC_NUM_BUFFERS][TRC_RING_CAP];  ///< Event buffers
    uint32_t counts[TRC_NUM_BUFFERS] = {0};       ///< Event counts per buffer
    uint32_t heads[TRC_NUM_BUFFERS] = {0};         ///< Next write position per buffer
    uint32_t depth = 0;                            ///< Current call depth
    uint32_t thread_id = 0;                        ///< Thread ID
    std::string thread_name;                       ///< Thread name
    
    Ring();
    ~Ring();
    
    bool write(const Event& event);
    bool write_msg(const char* msg, ...);
    bool should_auto_flush() const;
};


struct AsyncQueue {
    std::queue<Event> queue;
    std::mutex mutex;
    std::condition_variable cv;
    std::atomic<bool> running{false};
    std::thread worker;
    
    AsyncQueue();
    ~AsyncQueue();
    
    void push(const Event& event);
    void flush_now();
    void start();
    void stop();
};


struct Registry {
    std::unordered_map<uint32_t, std::unique_ptr<Ring>> rings;
    std::mutex mutex;
    
    Ring* get_ring(uint32_t thread_id);
    void flush_all();
    void clear();
};


struct Scope {
    const char* function;
    const char* file;
    uint32_t line;
    uint64_t start_time;
    
    Scope(const char* func, const char* f, uint32_t l);
    ~Scope();
};


struct FunctionStats {
    std::string name;
    uint64_t call_count = 0;
    uint64_t total_time_ns = 0;
    uint64_t min_time_ns = UINT64_MAX;
    uint64_t max_time_ns = 0;
};

struct ThreadStats {
    uint32_t thread_id = 0;
    std::string thread_name;
    uint64_t event_count = 0;
    uint64_t total_time_ns = 0;
    std::unordered_map<std::string, FunctionStats> functions;
};


extern Config config;
extern std::atomic<bool> stats_registered;

inline Config& get_config() {
    return config;

inline Registry& registry() {
    static Registry reg;
    return reg;

inline AsyncQueue& async_queue() {
    static AsyncQueue queue;
    return queue;


inline FILE* safe_fopen(const char* filename, const char* mode) {
#ifdef _MSC_VER
    FILE* file = nullptr;
    if (fopen_s(&file, filename, mode) != 0) {
        return nullptr;
    return file;
#else
    return std::fopen(filename, mode);
#endif

inline FILE* safe_tmpfile() {
#ifdef _MSC_VER
    FILE* file = nullptr;
    if (tmpfile_s(&file) != 0) {
        return nullptr;
    return file;
#else
    return std::tmpfile();
#endif

inline AsyncQueue& async_queue()

inline Config& get_config()

inline void flush_current_thread()

inline bool should_use_shared_memory() {
    Config& cfg = get_config();
    
    if (cfg.shared_memory_mode == SharedMemoryMode::DISABLED) {
        return false;
    if (cfg.shared_memory_mode == SharedMemoryMode::ENABLED) {
        return true;
    
    // AUTO mode: detect if shared memory already exists
    std::string shm_name = shared_memory::get_shared_memory_name();
    auto handle = shared_memory::create_or_open_shared_memory(
        shm_name.c_str(),
        sizeof(dll_shared_state::SharedTraceState),
        false  // try to open existing
    );
    
    bool exists = handle.valid;
    if (exists) {
        shared_memory::close_shared_memory(handle);
    return exists;

inline void print_event(const Event& e, FILE* out)

inline void set_external_state(Config* cfg, Registry* reg) {
    dll_shared_state::set_shared_config(cfg);
    dll_shared_state::set_shared_registry(reg);

inline Config& get_config() {
    return dll_shared_state::get_shared_config() ? *dll_shared_state::get_shared_config() : config;

inline bool load_config(const char* path) {
    return get_config().load_from_file(path);

inline bool filter_utils::should_trace(const char* func, const char* file, int depth) {
    const auto& f = get_config().filter;
    
    // Check depth filter
    if (f.max_depth >= 0 && depth > f.max_depth) {
        return false;
    
    // Check function filters
    if (func) {
        // If exclude list matches, filter out (exclude wins)
        if (matches_any(func, f.exclude_functions)) {
            return false;
        
        // If include list is not empty and doesn't match, filter out
        if (!f.include_functions.empty() && !matches_any(func, f.include_functions)) {
            return false;
    
    // Check file filters
    if (file) {
        // If exclude list matches, filter out (exclude wins)
        if (matches_any(file, f.exclude_files)) {
            return false;
        
        // If include list is not empty and doesn't match, filter out
        if (!f.include_files.empty() && !matches_any(file, f.include_files)) {
            return false;
    
    return true;  // Passed all filters

inline void filter_include_function(const char* pattern) {
    get_config().filter.include_functions.push_back(pattern);

inline void filter_exclude_function(const char* pattern) {
    get_config().filter.exclude_functions.push_back(pattern);

inline void filter_include_file(const char* pattern) {
    get_config().filter.include_files.push_back(pattern);

inline void filter_exclude_file(const char* pattern) {
    get_config().filter.exclude_files.push_back(pattern);

inline void filter_set_max_depth(int depth) {
    get_config().filter.max_depth = depth;

inline void filter_clear() {
    auto& f = get_config().filter;
    f.include_functions.clear();
    f.exclude_functions.clear();
    f.include_files.clear();
    f.exclude_files.clear();
    f.max_depth = -1;

inline Registry& registry() {
    if (dll_shared_state::get_shared_registry()) return *dll_shared_state::get_shared_registry();
    static Registry r;
    return r;

inline AsyncQueue& async_queue() {
    static AsyncQueue q;
    return q;

inline uint32_t thread_id_hash() {
    auto id = std::this_thread::get_id();
    std::hash<std::thread::id> h;
    uint64_t v = (uint64_t)h(id);
    // mix into a printable 32-bit value
    v ^= (v >> 33); v *= 0xff51afd7ed558ccdULL;
    v ^= (v >> 33); v *= 0xc4ceb9fe1a85ec53ULL;
    v ^= (v >> 33);
    return (uint32_t)(v & 0xffffffffu);

inline Ring& thread_ring() {
    // Check if we should use shared mode
    if (dll_shared_state::get_shared_registry() || should_use_shared_memory()) {
        // Shared memory path (existing logic)
        static thread_local Ring* cached_ring = nullptr;
        if (!cached_ring) {
            static thread_local ThreadRingGuard cleanup_guard;
            cached_ring = dll_shared_state::get_shared_registry()->get_or_create_thread_ring();
        return *cached_ring;
    
    // Thread-local path (existing logic)
    static thread_local Ring ring;
    static thread_local bool inited = false;
    if (!inited) {
        ring.tid = thread_id_hash();
        ring.color_offset = static_cast<uint8_t>(ring.tid % 8);
        registry().add(&ring);
        ring.registered = true;
        inited = true;
    return ring;

inline const char* base_name(const char* p) {
    if (!p) return "";
    const char* s1 = std::strrchr(p, '/');
    const char* s2 = std::strrchr(p, '\\');
    const char* s  = (s1 && s2) ? (s1 > s2 ? s1 : s2) : (s1 ? s1 : s2);
    return s ? (s + 1) : p;

inline void print_event(const Event& e, FILE* out) {
    // ANSI color for depth-based colorization with thread-aware offset
    if (get_config().colorize_depth) {
        // Combine depth and thread offset for visual distinction
        // Each thread gets a unique color offset, making multi-threaded traces easier to read
        int color_idx = (e.depth + e.color_offset) % 8;
        static const char* colors[] = {
            "\033[31m",  // Red
            "\033[32m",  // Green
            "\033[33m",  // Yellow
            "\033[34m",  // Blue
            "\033[35m",  // Magenta
            "\033[36m",  // Cyan
            "\033[37m",  // White
            "\033[91m"   // Bright Red
        };
        std::fprintf(out, "%s", colors[color_idx]);
    
    if (get_config().print_timestamp) {
        // Convert ns timestamp to human-readable ISO format with milliseconds
        auto duration = std::chrono::nanoseconds(e.ts_ns);
        auto tp = std::chrono::time_point<std::chrono::system_clock, std::chrono::nanoseconds>(duration);
        auto time_t_val = std::chrono::system_clock::to_time_t(
            std::chrono::time_point_cast<std::chrono::system_clock::duration>(tp));
        auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(duration) % 1000;
        
        std::tm tm_buf;
        #ifdef _WIN32
        localtime_s(&tm_buf, &time_t_val);
        #else
        localtime_r(&time_t_val, &tm_buf);
        #endif
        
        std::fprintf(out, "[%04d-%02d-%02d %02d:%02d:%02d.%03d] ",
            tm_buf.tm_year + 1900, tm_buf.tm_mon + 1, tm_buf.tm_mday,
            tm_buf.tm_hour, tm_buf.tm_min, tm_buf.tm_sec, (int)ms.count());
    if (get_config().print_thread)    std::fprintf(out, "(%08x) ", e.tid);

    // Filename:line:function prefix block (fixed widths), before indent so alignment is stable
    if (get_config().include_file_line && e.file) {
        bool printed_something = false;
        
        // Print filename if enabled
        if (get_config().include_filename) {
            const char* path = get_config().show_full_path ? e.file : base_name(e.file);
            const int fw = (get_config().filename_width > 0 ? get_config().filename_width : 20);
            
            // Head-truncate: show beginning of path (precision limits max chars printed)
            std::fprintf(out, "%-*.*s", fw, fw, path);
            printed_something = true;
        
        // Print line number and function name if enabled (they're paired)
        if (get_config().include_function_name) {
            const int lw = (get_config().line_width > 0 ? get_config().line_width : 5);
            const int funcw = (get_config().function_width > 0 ? get_config().function_width : 20);
            const char* fname = e.func ? e.func : "";
            
            // Print colon separator if filename was printed
            if (printed_something) std::fprintf(out, ":");
            
            // Print line number
            std::fprintf(out, "%*d", lw, e.line);
            
            // Head-truncate function name: show beginning (precision limits max chars)
            std::fprintf(out, " %-*.*s", funcw, funcw, fname);
            printed_something = true;
        
        if (printed_something) std::fprintf(out, " ");

    // Depth indentation after prefix
    if (get_config().show_indent_markers) {
        // Show visual markers for each level
        const char* marker = get_config().indent_marker ? get_config().indent_marker : "| ";
        for (int i = 0; i < e.depth; ++i) {
            std::fputs(marker, out);
    } else {
        // Plain whitespace indentation
        for (int i = 0; i < e.depth; ++i) {
            std::fputs("  ", out);

    // Event type markers
    const char* enter_mk = get_config().enter_marker ? get_config().enter_marker : "-> ";
    const char* exit_mk = get_config().exit_marker ? get_config().exit_marker : "<- ";
    const char* msg_mk = get_config().msg_marker ? get_config().msg_marker : "- ";

    switch (e.type) {
    case EventType::Enter:
        std::fprintf(out, "%s%s", enter_mk, e.func);
        break;
    case EventType::Exit:
        if (get_config().print_timing) {
            // Auto-scale units based on duration
            if (e.dur_ns < 1000ULL) {
                std::fprintf(out, "%s%s  [%llu ns]", exit_mk, e.func, (unsigned long long)e.dur_ns);
            } else if (e.dur_ns < 1000000ULL) {
                std::fprintf(out, "%s%s  [%.2f us]", exit_mk, e.func, e.dur_ns / 1000.0);
            } else if (e.dur_ns < 1000000000ULL) {
                std::fprintf(out, "%s%s  [%.2f ms]", exit_mk, e.func, e.dur_ns / 1000000.0);
            } else {
                std::fprintf(out, "%s%s  [%.3f s]", exit_mk, e.func, e.dur_ns / 1000000000.0);
        } else {
            std::fprintf(out, "%s%s", exit_mk, e.func);
        break;
    case EventType::Msg:
        std::fprintf(out, "%s%s", msg_mk, e.msg[0] ? e.msg : "");
        break;
    
    // Reset color and add newline
    if (get_config().colorize_depth) {
        std::fprintf(out, "\033[0m");  // Reset to default color
    std::fprintf(out, "\n");

inline void flush_ring(Ring& r) {
    static std::mutex io_mtx;
    FILE* out = get_config().out ? get_config().out : stdout;

    int flush_buf_idx = 0;
    uint32_t count = 0;
    uint32_t start = 0;
    
    // Double-buffering mode: swap buffers atomically
#if TRC_DOUBLE_BUFFER
    if (get_config().use_double_buffering) {
        std::lock_guard<std::mutex> flush_lock(r.flush_mtx);
        
        // Atomically swap active buffer
        int old_buf = r.active_buf.load(std::memory_order_relaxed);
        int new_buf = 1 - old_buf;
        r.active_buf.store(new_buf, std::memory_order_release);
        
        // Now flush the old buffer (no one is writing to it)
        flush_buf_idx = old_buf;
        count = (r.wraps[flush_buf_idx] == 0) ? r.head[flush_buf_idx] : TRC_RING_CAP;
        start = (r.wraps[flush_buf_idx] == 0) ? 0 : r.head[flush_buf_idx];
        
        // Print events from the flushed buffer
        {
            std::lock_guard<std::mutex> io_lock(io_mtx);
            for (uint32_t i = 0; i < count; ++i) {
                uint32_t idx = (start + i) % TRC_RING_CAP;
                const Event& e = r.buf[flush_buf_idx][idx];
                print_event(e, out);
            std::fflush(out);
        
        // Clear the flushed buffer for reuse
        r.head[flush_buf_idx] = 0;
        r.wraps[flush_buf_idx] = 0;
    else
#endif
    // Single-buffer mode: flush in-place (original behavior)
    {
        std::lock_guard<std::mutex> io_lock(io_mtx);
        
        flush_buf_idx = 0;
        count = (r.wraps[flush_buf_idx] == 0) ? r.head[flush_buf_idx] : TRC_RING_CAP;
        start = (r.wraps[flush_buf_idx] == 0) ? 0 : r.head[flush_buf_idx];
        
        for (uint32_t i = 0; i < count; ++i) {
            uint32_t idx = (start + i) % TRC_RING_CAP;
            const Event& e = r.buf[flush_buf_idx][idx];
            print_event(e, out);
        std::fflush(out);

inline void flush_all() {
    std::vector<Ring*> snapshot;
    { 
        std::lock_guard<std::mutex> lock(registry().mtx); 
        snapshot = registry().rings; 
    for (Ring* r : snapshot) {
        if (r && r->registered) {
            flush_ring(*r);

inline void flush_current_thread() {
    flush_ring(thread_ring());

inline void flush_immediate_queue() {
    async_queue().flush_now();

inline void start_async_immediate(FILE* out = nullptr) {
    if (!out) out = get_config().out ? get_config().out : stdout;
    async_queue().flush_interval_ms = get_config().immediate_flush_interval_ms;
    async_queue().batch_size = get_config().immediate_queue_size;
    async_queue().start(out);

inline void stop_async_immediate() {
    async_queue().stop();

inline void check_auto_flush_on_scope_exit(int final_depth) {
    if (get_config().auto_flush_at_exit && final_depth == 0) {
        flush_all();

inline std::string generate_dump_filename(const char* prefix = nullptr) {
    namespace fs = std::filesystem;
    
    if (!prefix) prefix = get_config().dump_prefix;
    const char* suffix = get_config().dump_suffix;
    
    auto now = std::chrono::system_clock::now();
    auto time_t_val = std::chrono::system_clock::to_time_t(now);
    auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(
        now.time_since_epoch()) % 1000;
    
    std::tm tm;
#ifdef _WIN32
    localtime_s(&tm, &time_t_val);
#else
    localtime_r(&time_t_val, &tm);
#endif
    
    // Build base path
    fs::path base_path;
    if (get_config().output_dir) {
        base_path = get_config().output_dir;
    } else {
        base_path = ".";
    
    // Add subdirectory based on layout
    fs::path dir_path;
    switch (get_config().output_layout) {
        case Config::OutputLayout::ByDate: {
            // Subdirectory: YYYY-MM-DD
            char date_buf[32];
            std::snprintf(date_buf, sizeof(date_buf), "%04d-%02d-%02d",
                          tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday);
            dir_path = base_path / date_buf;
            break;
        case Config::OutputLayout::BySession: {
            // Subdirectory: session_NNN
            int session = get_config().current_session;
            
            // Auto-increment: find max existing session number
            if (session == 0) {
                int max_session = 0;
                try {
                    if (fs::exists(base_path)) {
                        for (const auto& entry : fs::directory_iterator(base_path)) {
                            if (entry.is_directory()) {
                                std::string dirname = entry.path().filename().string();
                                if (dirname.substr(0, 8) == "session_") {
                                    int num = std::atoi(dirname.substr(8).c_str());
                                    max_session = std::max(max_session, num);
                } catch (...) {
                    // Ignore errors during auto-detection
                session = max_session + 1;
            
            char session_buf[32];
            std::snprintf(session_buf, sizeof(session_buf), "session_%03d", session);
            dir_path = base_path / session_buf;
            break;
        case Config::OutputLayout::Flat:
        default:
            // No subdirectory
            dir_path = base_path;
            break;
    
    // Create directory if it doesn't exist
    try {
        if (!dir_path.empty() && !fs::exists(dir_path)) {
            fs::create_directories(dir_path);
    } catch (const std::exception& e) {
        std::fprintf(stderr, "trace-scope: Failed to create directory %s: %s\n",
                     dir_path.string().c_str(), e.what());
        // Fall back to current directory
        dir_path = ".";
    
    // Generate filename
    char filename_buf[256];
    std::snprintf(filename_buf, sizeof(filename_buf), "%s_%04d%02d%02d_%02d%02d%02d_%03d%s",
                  prefix,
                  tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
                  tm.tm_hour, tm.tm_min, tm.tm_sec,
                  (int)ms.count(),
                  suffix);
    
    fs::path full_path = dir_path / filename_buf;
    return full_path.string();

inline std::string dump_binary(const char* prefix = nullptr) {
    std::string filename = generate_dump_filename(prefix);
    FILE* f = safe_fopen(filename.c_str(), "wb");
    if (!f) return "";

    auto w8  = [&](uint8_t v){ std::fwrite(&v,1,1,f); };
    auto w16 = [&](uint16_t v){ std::fwrite(&v,1,2,f); };
    auto w32 = [&](uint32_t v){ std::fwrite(&v,1,4,f); };
    auto w64 = [&](uint64_t v){ std::fwrite(&v,1,8,f); };
    auto ws  = [&](const char* s, uint16_t n){ if (n) std::fwrite(s,1,n,f); };

    std::fwrite("TRCLOG10",1,8,f);
    w32(2); // version (bumped to 2 for color_offset field)
    w32(0);

    std::vector<Ring*> snapshot;
    { std::lock_guard<std::mutex> lock(registry().mtx); snapshot = registry().rings; }

    for (Ring* r : snapshot) {
        if (!r || !r->registered) continue;
        
        // Determine which buffer(s) to dump
        int num_buffers = TRC_NUM_BUFFERS;
#if TRC_DOUBLE_BUFFER
        if (!get_config().use_double_buffering) {
            num_buffers = 1;  // Only dump first buffer if not using double-buffering
#endif
        
        for (int buf_idx = 0; buf_idx < num_buffers; ++buf_idx) {
            uint32_t count = (r->wraps[buf_idx] == 0) ? r->head[buf_idx] : TRC_RING_CAP;
            uint32_t start = (r->wraps[buf_idx] == 0) ? 0 : r->head[buf_idx];

            for (uint32_t i = 0; i < count; ++i) {
                uint32_t idx = (start + i) % TRC_RING_CAP;
                const Event& e = r->buf[buf_idx][idx];

                w8((uint8_t)e.type);
                w32(e.tid);
                w8(e.color_offset);  // Added in version 2 for thread-aware colors
                w64(e.ts_ns);
                w32((uint32_t)e.depth);
                w64(e.dur_ns);
                w64(e.memory_rss);  // Added in version 2 for memory tracking

                // file, func, msg as length-prefixed
                auto emit_str = [&](const char* s){
                    if (!s) { w16(0); return; }
                    uint16_t n = (uint16_t)std::min<size_t>(65535, std::strlen(s));
                    w16(n); ws(s, n);
                };
                emit_str(e.file);
                emit_str(e.func);
                emit_str(e.msg);
                w32((uint32_t)e.line);
    std::fclose(f);
    return filename;

inline void trace_msgf(const char* file, int line, const char* fmt, ...) {
#if TRC_ENABLED
    Ring& r = thread_ring();
    va_list ap;
    va_start(ap, fmt);
    r.write_msg(file, line, fmt, ap);
    va_end(ap);
#endif

inline void trace_arg(const char* file, int line, const char* name, const char* type_name) {
#if TRC_ENABLED
    std::ostringstream oss;
    oss << name << ": " << type_name;
    trace_msgf(file, line, "%s", oss.str().c_str());
#endif

inline void set_external_state(Config* cfg, Registry* reg) {
    if (cfg) {
        dll_shared_state::set_shared_config(cfg);
    if (reg) {
        dll_shared_state::set_shared_registry(reg);

inline bool load_config(const std::string& path) {
    return get_config().load_from_file(path);

inline void dump_stats() {
    // Implementation for dumping statistics
    // This would be implemented based on the original header

} // namespace trace

