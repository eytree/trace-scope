#pragma once
/**
 * @file trace_scope.hpp
 * @brief Single-header trace library (auto-generated)
 * 
 * This file is automatically generated from modular sources.
 * DO NOT EDIT THIS FILE DIRECTLY - edit the source modules instead.
 * 
 * Generated: 2025-10-27 23:13:09 UTC
 * Source modules: 16 files
 * 
 * Source files (in merge order):
 *   - platform.hpp
 *   - types/enums.hpp
 *   - types/event.hpp
 *   - types/config.hpp
 *   - types/ring.hpp
 *   - types/async_queue.hpp
 *   - types/registry.hpp
 *   - types/scope.hpp
 *   - types/stats.hpp
 *   - variables.hpp
 *   - functions.hpp
 *   - namespaces/stats.hpp
 *   - namespaces/shared_memory.hpp
 *   - namespaces/dll_shared_state.hpp
 *   - namespaces/internal.hpp
 *   - macros.hpp
 * 
 * To regenerate this file:
 *   python tools/merge_header.py --input include/trace-scope/trace_scope_modular --output include/trace-scope/trace_scope.hpp
 * 
 * Or use CMake (automatic):
 *   cmake --build . --target generate_header
 */

// Standard C++ includes
#include <algorithm>
#include <atomic>
#include <chrono>
#include <condition_variable>
#include <cstdarg>
#include <cstdint>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <filesystem>
#include <map>
#include <memory>
#include <mutex>
#include <queue>
#include <sstream>
#include <string>
#include <thread>
#include <unordered_map>
#include <vector>

// Platform-specific includes
#ifdef _WIN32
#include <windows.h>
#include <psapi.h>
// Undefine Windows macros that conflict with std::min/max
#undef min
#undef max
#elif defined(__APPLE__)
#include <mach/mach.h>
#include <mach/task.h>
#endif
#ifdef _WIN32
// Windows shared memory functions are in windows.h (already included)
#elif defined(__linux__) || defined(__APPLE__)
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#endif

// Build config defines
#ifndef TRC_SCOPE_API
#define TRC_SCOPE_API
#endif
#ifndef TRC_ENABLED
#define TRC_ENABLED 1
#endif
#ifndef TRC_RING_CAP
#define TRC_RING_CAP 4096
#endif
#ifndef TRC_MSG_CAP
#define TRC_MSG_CAP 192
#endif
#ifndef TRC_DEPTH_MAX
#define TRC_DEPTH_MAX 512
#endif
#ifndef TRC_DOUBLE_BUFFER
#define TRC_DOUBLE_BUFFER 0  // Default: disabled to save memory (~1.2MB per thread)
#endif
#define TRC_NUM_BUFFERS 2
#define TRC_SCOPE_VERSION "0.14.0-alpha"
#define TRC_SCOPE_VERSION_MAJOR 0
#define TRC_SCOPE_VERSION_MINOR 14
#define TRC_SCOPE_VERSION_PATCH 0

// Single namespace
namespace trace {


enum class EventType : uint8_t {
    Enter = 0,
    Exit = 1,
    Message = 2,
    Marker = 3
};

enum class TracingMode : uint8_t {
    Disabled = 0,
    Immediate = 1,
    Buffered = 2,
    Hybrid = 3
};

enum class FlushMode : uint8_t {
    Manual = 0,
    Auto = 1,
    Interval = 2
};

enum class SharedMemoryMode : uint8_t {
    Disabled = 0,
    Auto = 1,
    Enabled = 2
};


struct Event {
    uint64_t timestamp;           ///< Timestamp in nanoseconds
    EventType type;               ///< Event type
    uint32_t depth;              ///< Call stack depth
    const char* function;        ///< Function name
    const char* file;            ///< Source file
    uint32_t line;               ///< Source line
    char message[TRC_MSG_CAP];   ///< Message buffer
};


struct Config {
    TracingMode mode = TracingMode::Disabled;
    FlushMode flush_mode = FlushMode::Auto;
    SharedMemoryMode shared_memory_mode = SharedMemoryMode::Auto;
    uint32_t max_depth = TRC_DEPTH_MAX;
    bool auto_flush = true;
    uint32_t flush_interval_ms = 1000;

    struct {
        std::vector<std::string> include_functions;
        std::vector<std::string> exclude_functions;
        std::vector<std::string> include_files;
        std::vector<std::string> exclude_files;
        uint32_t max_depth = TRC_DEPTH_MAX;
    } filter;

    std::string config_file;
    FILE* output_file = nullptr;

    void load_from_file(const std::string& path);
    void save_to_file(const std::string& path) const;
};


struct Ring {
    Event buffers[TRC_NUM_BUFFERS][TRC_RING_CAP];  ///< Event buffers
    uint32_t counts[TRC_NUM_BUFFERS] = {0};       ///< Event counts per buffer
    uint32_t heads[TRC_NUM_BUFFERS] = {0};         ///< Next write position per buffer
    uint32_t depth = 0;                            ///< Current call depth
    uint32_t thread_id = 0;                        ///< Thread ID
    std::string thread_name;                       ///< Thread name

    Ring();
    ~Ring();

    bool write(const Event& event);
    bool write_msg(const char* msg, ...);
    bool should_auto_flush() const;
};


struct AsyncQueue {
    std::queue<Event> queue;
    std::mutex mutex;
    std::condition_variable cv;
    std::atomic<bool> running{false};
    std::thread worker;

    AsyncQueue();
    ~AsyncQueue();

    void push(const Event& event);
    void flush_now();
    void start();
    void stop();
};


struct Registry {
    std::unordered_map<uint32_t, std::unique_ptr<Ring>> rings;
    std::mutex mutex;

    Ring* get_ring(uint32_t thread_id);
    void flush_all();
    void clear();
};


struct Scope {
    const char* function;
    const char* file;
    uint32_t line;
    uint64_t start_time;

    Scope(const char* func, const char* f, uint32_t l);
    ~Scope();
};


struct FunctionStats {
    std::string name;
    uint64_t call_count = 0;
    uint64_t total_time_ns = 0;
    uint64_t min_time_ns = UINT64_MAX;
    uint64_t max_time_ns = 0;
};

struct ThreadStats {
    uint32_t thread_id = 0;
    std::string thread_name;
    uint64_t event_count = 0;
    uint64_t total_time_ns = 0;
    std::unordered_map<std::string, FunctionStats> functions;
};


extern Config config;
extern std::atomic<bool> stats_registered;

inline Config& get_config() {
    return config;
}

inline Registry& registry() {
    static Registry reg;
    return reg;
}

inline AsyncQueue& async_queue() {
    static AsyncQueue queue;
    return queue;
}


// Placeholder implementations - would need to be filled from original header
inline void set_external_state(Config* cfg, Registry* reg) {
    // Implementation from original header
}

inline bool load_config(const std::string& path) {
    return get_config().load_from_file(path);
}

inline void dump_stats() {
    // Implementation from original header
}

inline void filter_include_function(const std::string& func) {
    get_config().filter.include_functions.push_back(func);
}

inline void filter_exclude_function(const std::string& func) {
    get_config().filter.exclude_functions.push_back(func);
}

inline void filter_include_file(const std::string& file) {
    get_config().filter.include_files.push_back(file);
}

inline void filter_exclude_file(const std::string& file) {
    get_config().filter.exclude_files.push_back(file);
}

inline void filter_set_max_depth(uint32_t depth) {
    get_config().filter.max_depth = depth;
}

inline void filter_clear() {
    get_config().filter.include_functions.clear();
    get_config().filter.exclude_functions.clear();
    get_config().filter.include_files.clear();
    get_config().filter.exclude_files.clear();
}

inline void flush_immediate_queue() {
    async_queue().flush_now();
}

inline void start_async_immediate() {
    async_queue().start();
}

inline void stop_async_immediate() {
    async_queue().stop();
}

inline void ensure_stats_registered() {
    if (!stats_registered.load()) {
        stats_registered.store(true);
    }
}

inline std::string generate_dump_filename(const char* prefix = nullptr) {
    return "trace_dump.bin";
}

inline std::string dump_binary(const char* prefix = nullptr) {
    return "trace_dump.bin";
}

namespace stats {

inline void register_function(const std::string& name, uint64_t duration_ns) {
    // Implementation from original header
}

inline void register_thread(uint32_t thread_id, const std::string& name) {
    // Implementation from original header
}

} // namespace stats
namespace shared_memory {

inline bool create_shared_memory(const std::string& name, size_t size) {
    // Implementation from original header
    return false;
}

inline void* map_shared_memory(const std::string& name) {
    // Implementation from original header
    return nullptr;
}

} // namespace shared_memory
namespace dll_shared_state {

inline void set_shared_config(Config* cfg) {
    // Implementation from original header
}

inline void set_shared_registry(Registry* reg) {
    // Implementation from original header
}

inline Config* get_shared_config() {
    // Implementation from original header
    return nullptr;
}

inline Registry* get_shared_registry() {
    // Implementation from original header
    return nullptr;
}

} // namespace dll_shared_state
namespace internal {

inline void log_error(const std::string& message) {
    // Implementation from original header
}

inline void log_debug(const std::string& message) {
    // Implementation from original header
}

} // namespace internal



// trace_msgf function
inline void trace_msgf(const char* file, int line, const char* fmt, ...) {
#if TRC_ENABLED
    Ring& r = thread_ring();
    va_list ap;
    va_start(ap, fmt);
    r.write_msg(file, line, fmt, ap);
    va_end(ap);
#endif
}

// safe_fopen function
inline FILE* safe_fopen(const char* filename, const char* mode) {
#ifdef _MSC_VER
    FILE* file = nullptr;
    if (fopen_s(&file, filename, mode) != 0) {
        return nullptr;
    }

// flush_ring function
inline void flush_ring(Ring& r) {
    static std::mutex io_mtx;
    FILE* out = get_config().out ? get_config().out : stdout;

    int flush_buf_idx = 0;
    uint32_t count = 0;
    uint32_t start = 0;
    
    // Double-buffering mode: swap buffers atomically
#if TRC_DOUBLE_BUFFER
    if (get_config().use_double_buffering) {
        std::lock_guard<std::mutex> flush_lock(r.flush_mtx);
        
        // Atomically swap active buffer
        int old_buf = r.active_buf.load(std::memory_order_relaxed);
        int new_buf = 1 - old_buf;
        r.active_buf.store(new_buf, std::memory_order_release);
        
        // Now flush the old buffer (no one is writing to it)
        flush_buf_idx = old_buf;
        count = (r.wraps[flush_buf_idx] == 0) ? r.head[flush_buf_idx] : TRC_RING_CAP;
        start = (r.wraps[flush_buf_idx] == 0) ? 0 : r.head[flush_buf_idx];
        
        // Print events from the flushed buffer
        {
            std::lock_guard<std::mutex> io_lock(io_mtx);
            for (uint32_t i = 0; i < count; ++i) {
                uint32_t idx = (start + i) % TRC_RING_CAP;
                const Event& e = r.buf[flush_buf_idx][idx];
                print_event(e, out);
            }

// flush_all function
inline void flush_all() {
    std::vector<Ring*> snapshot;
    { 
        std::lock_guard<std::mutex> lock(registry().mtx); 
        snapshot = registry().rings; 
    }

// Config output_file field
    FILE* output_file = nullptr;
} // namespace trace

// Macros (outside namespace)
#define TRC_SETUP_DLL_SHARED_WITH_CONFIG(config_file) \
    static trace::Config g_trace_shared_config; \
    static trace::Registry g_trace_shared_registry; \
    static trace::Scope g_trace_setup_scope(__func__, __FILE__, __LINE__)
#define TRC_SETUP_DLL_SHARED() TRC_SETUP_DLL_SHARED_WITH_CONFIG(nullptr)
#define TRC_SCOPE() ::trace::Scope _trace_scope_obj(__func__, __FILE__, __LINE__)
#define TRC_MSG(...) ::trace::trace_msgf(__FILE__, __LINE__, __VA_ARGS__)
#define TRC_LOG ::trace::TraceStream(__FILE__, __LINE__)
#define TRC_CONTAINER(container, max_elements) ::trace::format_container(container, max_elements)
#define TRC_ARG(...) ::trace::trace_arg(__FILE__, __LINE__, __VA_ARGS__)

